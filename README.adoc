= Advent of code 2024
:toc:

image:https://godoc.org/gitlab.com/jhinrichsen/adventofcode2024?status.svg["godoc", link="https://godoc.org/gitlab.com/jhinrichsen/adventofcode2024"]
image:https://goreportcard.com/badge/gitlab.com/jhinrichsen/adventofcode2024["Go report card", link="https://goreportcard.com/report/gitlab.com/jhinrichsen/adventofcode2024"]
image:https://gitlab.com/jhinrichsen/adventofcode2024/badges/main/pipeline.svg[link="https://gitlab.com/jhinrichsen/adventofcode2024/-/commits/main",title="pipeline status"]
image:https://gitlab.com/jhinrichsen/adventofcode2024/badges/main/coverage.svg[link="https://gitlab.com/jhinrichsen/adventofcode2024/badges/main/coverage.svg",title="coverage report"]


My take on https://adventofcode.com/2024/ in Go. As usual, i don't particularly
care if i provide my solutions _fast_, i try to be _correct_ on the first
answer, and care for being runtime efficient.
All puzzles are backed by unit testing the examples and the puzzles.
Results are hard coded into the unit tests, so you might not want to peek at `_test.go` files.

== Environment

- Go 1.23
- vim, vim-go, gopls, fed by an HHKB
- VisualStudio Code for debugging
- Fedora 41 @ Framework 16" (AMD Ryzen 7 7840HS w/ Radeon 780M Graphics), 256 KiB L1d, 256 KiB L1i
- Fedora 41 @ custom built AMD Ryzen 5 3400G on a Gigabyte B450
- macOS @ 16" Macbook Pro 2019 (Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz)

== Project structure

Each puzzle for day `n` lives in a `day{{.n}}.go` and `day{{.n}}_test.go` file.
Unit test data, both examples and puzzle input, is in
`testdata/day{{.n}}.txt`, and `testdata/day{{.n}}_example.txt`.

== Overview

Number of tries for a correct answer:

|===
| Day | Part 1 | Part 2
| 1   |   1    |   1
| 2   |   1    |   1
| 3   |   1    |   3
| 4   |   1    |   1
| 5   |   1    |   1
| 6   |   1    |   1
| 7   |   1    |   1
| 8   |   1    |   1
| 9   |   1    |   1
| 10  |   1    |   1
| 11  |   2<1> |   1
| 12  |   1    |   1
| 13  |   1    |
| 14  |        |
| 15  |        |
| 16  |        |
| 17  |        |
| 18  |        |
| 19  |        |
| 20  |        |
| 21  |        |
| 22  |        |
| 23  |        |
| 24  |        |
| 25  |        |
|===
<1> error in bit shifting logic determining number of digits in a number

Total runtime so far:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay01Part1-8   	   10000	    133619 ns/op	   16384 B/op	       2 allocs/op
BenchmarkDay01Part2-8   	   10000	    122981 ns/op	   57374 B/op	       4 allocs/op
BenchmarkDay02Part1-8   	    4788	    275458 ns/op	  109453 B/op	    1007 allocs/op
BenchmarkDay02Part2-8   	    1605	    645229 ns/op	  309248 B/op	    4509 allocs/op
BenchmarkDay03Part1-8   	     934	   1359496 ns/op	  157584 B/op	    1543 allocs/op
BenchmarkDay03Part2-8   	     583	   2208954 ns/op	  165925 B/op	    1711 allocs/op
BenchmarkDay04Part1-8   	    2104	    568110 ns/op	   48544 B/op	     154 allocs/op
BenchmarkDay04Part2-8   	    3135	    417356 ns/op	   48544 B/op	     154 allocs/op
BenchmarkDay05Part1-8   	      55	  20832291 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay05Part2-8   	      21	  51428549 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay06Part1-8   	    1938	    701061 ns/op	  663580 B/op	       2 allocs/op

BenchmarkDay07Part1-8   	     445	   2474109 ns/op	       0 B/op	       0 allocs/op

BenchmarkDay08Part1-8   	    1798	    672954 ns/op	   90136 B/op	       2 allocs/op
BenchmarkDay08Part2-8   	    2086	    655172 ns/op	   90139 B/op	       2 allocs/op
----

That's 82 ms total.

----
go test -run=^$ -bench=Day -benchmem | tee benches/all.txt
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay01Part1-16    	   36889	     30237 ns/op	   16384 B/op	       2 allocs/op
BenchmarkDay01Part2-16    	   31315	     36905 ns/op	   53328 B/op	       7 allocs/op
BenchmarkDay02Part1-16    	  188276	      6090 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay02Part2-16    	   12307	     95254 ns/op	  199737 B/op	    3502 allocs/op
BenchmarkDay03Part1-16    	    2896	    383072 ns/op	  157598 B/op	    1543 allocs/op
BenchmarkDay03Part2-16    	    1574	    717401 ns/op	  165976 B/op	    1711 allocs/op
BenchmarkDay04Part1-16    	   10624	    115248 ns/op	   23616 B/op	     141 allocs/op
BenchmarkDay04Part2-16    	   45325	     26349 ns/op	   23616 B/op	     141 allocs/op
BenchmarkDay05Part1-16    	      99	  11922306 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay05Part2-16    	      36	  29796143 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay06Part1-16    	    3771	    296899 ns/op	  895652 B/op	     196 allocs/op

BenchmarkDay07Part1-16    	     843	   1364444 ns/op	       0 B/op	       0 allocs/op

BenchmarkDay08Part1-16    	    4962	    244642 ns/op	  109216 B/op	       9 allocs/op
BenchmarkDay08Part2-16    	    4339	    273104 ns/op	  109216 B/op	       9 allocs/op
BenchmarkDay09Part1-16    	      60	  17348834 ns/op	  327680 B/op	       1 allocs/op

BenchmarkDay10Part1-16    	    1741	    606704 ns/op	 1478965 B/op	   13295 allocs/op
BenchmarkDay10Part2-16    	    1994	    536712 ns/op	 1380583 B/op	   13290 allocs/op
BenchmarkDay11Part1-16    	    3156	    335200 ns/op	  308456 B/op	     305 allocs/op
BenchmarkDay11Part2-16    	     111	  10603092 ns/op	 8801646 B/op	    1974 allocs/op
PASS
ok  	gitlab.com/jhinrichsen/adventofcode2024	27.748s
awk -f total.awk < benches/all.txt
74738636 ns, 74738 μs, 74 ms, 0 s
----

== Day 1: Historian Hysteria

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay01Part1-16    	   40551	     29019 ns/op	   16384 B/op	       2 allocs/op <1>
BenchmarkDay01Part1-16    	   39687	     28998 ns/op	   16384 B/op	       2 allocs/op
BenchmarkDay01Part1-16    	   41421	     28890 ns/op	   16384 B/op	       2 allocs/op
BenchmarkDay01Part1-16    	   40461	     28838 ns/op	   16384 B/op	       2 allocs/op
BenchmarkDay01Part1-16    	   40435	     29237 ns/op	   16384 B/op	       2 allocs/op
BenchmarkDay01Part2-16    	   29532	     40068 ns/op	   57374 B/op	       4 allocs/op <2>
BenchmarkDay01Part2-16    	   30114	     40194 ns/op	   57374 B/op	       4 allocs/op
BenchmarkDay01Part2-16    	   29638	     39958 ns/op	   57374 B/op	       4 allocs/op
BenchmarkDay01Part2-16    	   29630	     40373 ns/op	   57374 B/op	       4 allocs/op
BenchmarkDay01Part2-16    	   29608	     40189 ns/op	   57374 B/op	       4 allocs/op
----
<1> left and right slice, each len(1000) X 64 bit integer, memory is O(2*N)
<2> the above plus a histogram for the right list, memory is (O(2*N + N))

By using smaller int types (uint -> uint32, uint16) `B/op` could be decreased, but 16 KiB fits into L1 cache.

== Day 2: Red-Nosed Reports

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay02Part1-16    	    9501	    123002 ns/op	  191264 B/op	    2552 allocs/op
BenchmarkDay02Part2-16    	    5326	    221674 ns/op	  396720 B/op	    6266 allocs/op
PASS
----

== Day 3: Mull it over

Usually i try to avoid regular expressions, as they quickly become hard to understand.
No way around `regexp` package in this puzzle.

People keep praising Python for its brevity in code golf.

[quote]
Me gopher staring at 5 lines of Python code
- Reddit user

They surely have a good point, although sometimes statically typed Go doing just fine.

=== Part 1

[source, Go]
----
func Day03(lines []string) (sum uint) {
        atoi := func(s string) (n uint) { <1>
                for i := range s {
                        n = 10*n + uint(s[i]-'0')
                }
                return <2>
        }
        re := regexp.MustCompile(`mul\((\d{1,3}),(\d{1,3})\)`)
        for i := range lines {
                gs := re.FindAllStringSubmatch(lines[i], -1)
                for j := range gs {
                        sum += atoi(gs[j][1]) * atoi(gs[j][2])
                }
        }
        return <2>
}
----
<1> custom atoi() instead of strconv.Atoi()
<2> yes, that is rather opinionated

I am using a fast custom parser because `strconv.Atoi()` is way more elaborate (error handling, negative values, `e` notation, ...) than our use case requires.
The regexp already makes sure of 1 to 3 digits, so no additional logic required.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay03Part1-16    	    6162	    192923 ns/op	  125182 B/op	    1564 allocs/op
BenchmarkDay03Part1-16    	    6196	    194894 ns/op	  125120 B/op	    1564 allocs/op
BenchmarkDay03Part1-16    	    5199	    193495 ns/op	  125184 B/op	    1564 allocs/op
BenchmarkDay03Part1-16    	    5224	    193238 ns/op	  125096 B/op	    1564 allocs/op
BenchmarkDay03Part1-16    	    6243	    191711 ns/op	  125127 B/op	    1564 allocs/op
PASS
----

=== Part 2

Using a `do()|don't()` RE to build hot and cold regions, then apply part 1 in hot regions.

----
xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5)
++++++++++++++++++++                                       +++++++++++++ <1>
 ******** <2>
                            ******** <3>
                                                *********
                                                                ********
----
<1> `+` indicates enabled region
<2> match group in an enabled region
<3> match group in a disabled region

My first try was wrong, i was intentionally treating multiple lines separately.
Many regexp parsers have an option for single string/ multiple lines.
I was just misguided because most puzzles are line oriented, obviously this one is not.

My second guess was also wrong, i pass part 1 or part 2 as a parameter into the `Day03` function,
and stupidly passed the wrong value. More coffee?

After a coffee, i removed all region housekeeping, extended the RE by `|do()|don't`,
and just toggled `enabled` flag.

When treating the puzzle input as one program, not multiple lines, stats go up for part 1.

----
name           old time/op    new time/op    delta
Day03Part1-16     193µs ± 1%     411µs ± 3%  +112.47%  (p=0.008 n=5+5)

name           old alloc/op   new alloc/op   delta
Day03Part1-16     125kB ± 0%     158kB ± 0%   +25.92%  (p=0.008 n=5+5)

name           old allocs/op  new allocs/op  delta
Day03Part1-16     1.56k ± 0%     1.54k ± 0%    -1.34%  (p=0.008 n=5+5)
----

Benchmark for part 2:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay03Part2-16    	    1332	    851205 ns/op	  165921 B/op	    1710 allocs/op
BenchmarkDay03Part2-16    	    1305	    938589 ns/op	  165923 B/op	    1710 allocs/op
BenchmarkDay03Part2-16    	    1395	    825859 ns/op	  165929 B/op	    1710 allocs/op
BenchmarkDay03Part2-16    	    1414	    877336 ns/op	  165951 B/op	    1710 allocs/op
BenchmarkDay03Part2-16    	    1472	    813813 ns/op	  165901 B/op	    1710 allocs/op
PASS
----

== Day 4: Ceres Search

=== Part 1

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay04Part1-16    	    5364	    224012 ns/op	   48560 B/op	     154 allocs/op
BenchmarkDay04Part1-16    	    5380	    223078 ns/op	   48559 B/op	     154 allocs/op
BenchmarkDay04Part1-16    	    5467	    222404 ns/op	   48560 B/op	     154 allocs/op
BenchmarkDay04Part1-16    	    4488	    222880 ns/op	   48560 B/op	     154 allocs/op
BenchmarkDay04Part1-16    	    5368	    219925 ns/op	   48560 B/op	     154 allocs/op
PASS
----

=== Part 2

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay04Part1-16    	    5394	    219828 ns/op	   48561 B/op	     154 allocs/op
BenchmarkDay04Part1-16    	    5421	    222877 ns/op	   48560 B/op	     154 allocs/op
BenchmarkDay04Part1-16    	    5377	    220939 ns/op	   48559 B/op	     154 allocs/op
BenchmarkDay04Part1-16    	    4857	    220370 ns/op	   48559 B/op	     154 allocs/op
BenchmarkDay04Part1-16    	    5455	    223552 ns/op	   48559 B/op	     154 allocs/op
BenchmarkDay04Part2-16    	   12849	     93220 ns/op	   48560 B/op	     154 allocs/op
BenchmarkDay04Part2-16    	   12699	     93705 ns/op	   48560 B/op	     154 allocs/op
BenchmarkDay04Part2-16    	   12814	     94808 ns/op	   48559 B/op	     154 allocs/op
BenchmarkDay04Part2-16    	   12862	     94259 ns/op	   48559 B/op	     154 allocs/op
BenchmarkDay04Part2-16    	   12758	     93285 ns/op	   48559 B/op	     154 allocs/op
PASS
----

== Day 5: Print Queue

=== Part 1

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay05Part1-16    	     378	   3107355 ns/op	    2688 B/op	       1 allocs/op
BenchmarkDay05Part1-16    	     386	   2970485 ns/op	    2688 B/op	       1 allocs/op
BenchmarkDay05Part1-16    	     393	   2939942 ns/op	    2688 B/op	       1 allocs/op
BenchmarkDay05Part1-16    	     403	   3054037 ns/op	    2688 B/op	       1 allocs/op
BenchmarkDay05Part1-16    	     398	   2887172 ns/op	    2688 B/op	       1 allocs/op
PASS
----

Removing GC...

----
name           old time/op    new time/op    delta
Day05Part1-16    2.99ms ± 4%    2.99ms ± 0%      ~     (p=0.690 n=5+5)

name           old alloc/op   new alloc/op   delta
Day05Part1-16    2.69kB ± 0%    0.00kB       -100.00%  (p=0.008 n=5+5)

name           old allocs/op  new allocs/op  delta
Day05Part1-16      1.00 ± 0%      0.00       -100.00%  (p=0.008 n=5+5)
----

=== Part 2

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay05Part2-16    	      39	  29821854 ns/op	       0 B/op	       0 allocs/op <1>
BenchmarkDay05Part2-16    	      34	  30269073 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay05Part2-16    	      38	  30446051 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay05Part2-16    	      36	  30861993 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay05Part2-16    	      32	  31323378 ns/op	       0 B/op	       0 allocs/op
PASS
----
<1> That's 30 ms for part 2, no heap allocation -> no garbage collection

== Day 6: Guard Gallivant

=== Part 1

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay06Part1-16    	    4609	    243924 ns/op	  895651 B/op	     196 allocs/op
----

=== Part 2

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay06Part2-16    	      21	  55184398 ns/op	  969380 B/op	     197 allocs/op
----

That's 55ms for part 2.

=== Optimization Analysis

**Original brute force approach** (14.5 seconds):
- Tests all 17,161 grid positions as potential obstructions
- Uses `map[state]struct{}` for loop detection with expensive hash operations
- Allocates new map for each simulation (4.1M allocations total)

**Optimized approach** (55ms):

1. **Path-only testing**: Only test obstruction positions on the guard's original path (~4,900 positions vs 17,161 total). This optimization is valid because only positions the guard visits can potentially cause loops when blocked.

2. **Array-based state tracking**: Replace `map[state]struct{}` with `[]bool` using packed state indices:
   ```
   stateIdx = pos.Y*dimX*4 + pos.X*4 + direction
   ```
   Array lookups are ~10x faster than map hash operations.

3. **State reuse**: Clear and reuse the same visited array instead of allocating new maps for each simulation, reducing GC pressure.

**Benchstat comparison**:
----
              │ bench_before.txt │         bench_after.txt         │
              │      sec/op      │    sec/op     vs base           │
Day06Part2-16    14513.03m ± ∞ ¹   54.56m ± ∞ ¹  ~ (p=0.333 n=1+5)

              │  bench_before.txt  │         bench_after.txt         │
              │        B/op        │     B/op       vs base          │
Day06Part2-16   98804508.5Ki ± ∞ ¹   946.7Ki ± ∞ ¹  -100.00% (n=1+5)

              │ bench_before.txt │        bench_after.txt         │
              │    allocs/op     │  allocs/op   vs base           │
Day06Part2-16    4133206.0 ± ∞ ¹   197.0 ± ∞ ¹  ~ (p=1.667 n=1+5)
----

**Performance improvement**: ~266x faster runtime, ~104,000x less memory usage

== Day 7: Bridge Repair

=== Part 1

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics     
BenchmarkDay07Part1-16              1312            916007 ns/op               0 B/op          0 allocs/op
----

=== Part 2

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics     
BenchmarkDay07Part2-16                66          18897873 ns/op               0 B/op          0 allocs/op
----

That's ~0.9ms for part 1 and ~19ms for part 2.

=== Optimization Analysis

**Original approach** (full enumeration):
- Tests all 2^n combinations for Part 1, 3^n for Part 2
- Systematic but inefficient for large equation sets

**Optimized approach** (stack-based traversal):

1. **Stack-based exploration**: Uses fixed-size stack to traverse only viable solution paths
2. **Aggressive pruning**: Immediately discards branches where `result > target`
3. **Early termination**: Stops as soon as first valid solution is found
4. **Zero allocations**: Uses stack array instead of heap allocations

**Benchstat comparison**:
----
              │ day07_benchmarks.txt │         day07_optimized.txt         │
              │        sec/op        │    sec/op     vs base               │
Day07Part1-16          4979.1µ ± ∞ ¹   899.0µ ± ∞ ¹  -81.95% (p=0.008 n=5)
Day07Part2-16          482.80m ± ∞ ¹   18.79m ± ∞ ¹  -96.11% (p=0.008 n=5)
geomean                 49.03m         4.110m        -91.62%
----

**Performance improvement**: ~82% faster Part 1, ~96% faster Part 2, ~92% overall improvement

== Day 8: Resonant Collinearity

=== Part 1

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay08Part1-8   	    1564	    661012 ns/op	   90139 B/op	       2 allocs/op
BenchmarkDay08Part1-8   	    1797	    631212 ns/op	   90136 B/op	       2 allocs/op
BenchmarkDay08Part1-8   	    2593	    630481 ns/op	   90136 B/op	       2 allocs/op
BenchmarkDay08Part1-8   	    1716	    678508 ns/op	   90136 B/op	       2 allocs/op
BenchmarkDay08Part1-8   	    1820	    648858 ns/op	   90136 B/op	       2 allocs/op
goos: linux
----

=== Part 2

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay08Part2-8   	    2032	    647094 ns/op	   90139 B/op	       2 allocs/op
BenchmarkDay08Part2-8   	    2167	    616031 ns/op	   90140 B/op	       2 allocs/op
BenchmarkDay08Part2-8   	    2073	    652428 ns/op	   90139 B/op	       2 allocs/op
BenchmarkDay08Part2-8   	    1794	    638548 ns/op	   90139 B/op	       2 allocs/op
BenchmarkDay08Part2-8   	    1544	    649896 ns/op	   90140 B/op	       2 allocs/op
----

Being an electrical engineer, i misread part 1 to stop after one complete wave.
The unit test was my safety net.
I lazily used

[source, Go]
----
for range 1 {
    ....
}
----

to stop iterating.
Part 2 was exactly that, my part 1.

Part 1 decreased slightly

----
name          old time/op    new time/op    delta
Day08Part1-8     711µs ± 5%     650µs ± 4%  -8.55%  (p=0.016 n=5+5)

name          old alloc/op   new alloc/op   delta
Day08Part1-8    90.1kB ± 0%    90.1kB ± 0%    ~     (all equal)

name          old allocs/op  new allocs/op  delta
Day08Part1-8      2.00 ± 0%      2.00 ± 0%    ~     (all equal)
----

Performancewise, part 1 and 2 are very similar, suggesting that the major part is locating antennas on the same frequency, as opposed to spreading the wave.

== Day 9: Disk Fragmenter

=== Part 1

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay09Part1-8   	      42	  27858720 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay09Part1-8   	      42	  27579218 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay09Part1-8   	      40	  28169173 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay09Part1-8   	      40	  28437979 ns/op	       0 B/op	       0 allocs/op
BenchmarkDay09Part1-8   	      40	  28237083 ns/op	       0 B/op	       0 allocs/op
----

That's 27 ms.

== Day10: Hoof It

=== Part 1

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay10Part1-16    	     996	   1124976 ns/op	 1459165 B/op	   13245 allocs/op
BenchmarkDay10Part1-16    	     981	   1129558 ns/op	 1459171 B/op	   13245 allocs/op
BenchmarkDay10Part1-16    	    1702	    656466 ns/op	 1459166 B/op	   13245 allocs/op
BenchmarkDay10Part1-16    	    1764	    642919 ns/op	 1459166 B/op	   13245 allocs/op
BenchmarkDay10Part1-16    	    1790	    638223 ns/op	 1459165 B/op	   13245 allocs/op
PASS
----

I misread part 1 and counted _all_ trails, not just _distinct_ start and end trails.
For part 2, this turns out to be just what we need, lucky me...

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay10Part2-16    	    1028	   1007849 ns/op	 1377221 B/op	   13243 allocs/op
BenchmarkDay10Part2-16    	    1116	   1018253 ns/op	 1377216 B/op	   13243 allocs/op
BenchmarkDay10Part2-16    	    1926	    587530 ns/op	 1377217 B/op	   13243 allocs/op
BenchmarkDay10Part2-16    	    1875	    569882 ns/op	 1377217 B/op	   13243 allocs/op
BenchmarkDay10Part2-16    	    1897	    581965 ns/op	 1377217 B/op	   13243 allocs/op
PASS
----

== Day 11: Plutonian Pebbles

The stone transformation rules require frequent digit counting and splitting of even-digit numbers.
A naive approach would use `strconv.Itoa()` + `len()` or `math.Log10()`, but both are expensive:

- `math.Log10()`: ~100-200 CPU cycles (floating-point operations)
- String conversion: Memory allocation + GC pressure

Instead, we use a branchless digit counting algorithm that operates purely on integers:

[source, Go]
----
func digits_branchless(n uint64) int {
	d := 1
	d += int((n - 10) >> 63) ^ 1           // >= 10?
	d += int((n - 100) >> 63) ^ 1          // >= 100?
	d += int((n - 1000) >> 63) ^ 1         // >= 1000?
	// ... up to 10^11 <1>
	return d
}
----
<1> This is what GPT-5 came up with, but 10^11^ is wrong, it must be 10^18^

Each comparison uses bit manipulation to avoid branches:

- `(n - threshold) >> 63` extracts the sign bit (1 if n < threshold, 0 if n >= threshold)
- `^ 1` flips it (0 if n < threshold, 1 if n >= threshold)
- Sum all results to get digit count

**Performance characteristics:**

- **Theoretical**: ~45 CPU cycles (11 comparisons × 4 ops each + setup)
- **Actual (modern AMD64)**: ~8-12 cycles due to superscalar execution and instruction-level parallelism
- **Advantage**: 10-20x faster than `math.Log10()`, completely branchless (no branch prediction misses)

**Implementation note:** An earlier attempt used a binary-tree style approach with power-of-10 thresholds (10^10, 10^5, 10^2, 10^1) and complex arithmetic to combine results, which was theoretically more elegant but contained subtle bugs in the threshold calculations and number reduction logic. The simpler linear approach above proved more reliable while maintaining equivalent performance.

The algorithm also handles the iteration challenge: when splitting stones during iteration, we iterate backwards through the slice to avoid index shifting issues when inserting new elements.

=== Optimization: Frequency Counting vs Slice Operations

**Initial Implementation (Slice-based)**:
----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay11Part1-16    	       2	2026317200 ns/op	 7208584 B/op	      31 allocs/op
PASS
----

~2.0 seconds for part 1 (25 blinks). The exponential stone growth dominated performance through `runtime.memmove` (99.33% CPU time in slice insertions).

**Optimized Implementation (Frequency Counting)**:
----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2024
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay11Part1-16    	    3186	    342996 ns/op	  308458 B/op	     305 allocs/op
BenchmarkDay11Part2-16    	      96	  10807918 ns/op	 8823100 B/op	    1976 allocs/op
PASS
----

**Performance Improvement**:

- **Part 1**: 345µs (~5,900x faster, from 2.0s to 0.3ms)
- **Part 2**: 10.9ms (75 blinks, 207+ trillion stones)

**Key Optimizations**:

1. **Frequency Counting**: Track stone counts instead of individual stones
2. **Iterative Processing**: Pure iteration, zero recursion
3. **Mathematical Insight**: Identical stones transform identically
4. **Memory Efficiency**: Constant memory usage regardless of stone count

The optimized approach scales with unique stone types (~100-1000) rather than total stone count (trillions), achieving subsecond performance for both parts.

